#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#include "../shader_common.glsl"
#include "../raytracing_common.glsl"

layout(location = 0) rayPayloadEXT DIRayPayload diPayload;

layout(set = 0, binding = 0) uniform CAMERA { Camera camera; };

layout(set = 1, binding = 0) uniform accelerationStructureEXT TLAS;
layout(set = 1, binding = 1) uniform sampler2D GBufferAlbedo;
layout(set = 1, binding = 2) uniform sampler2D GBufferEmission;
layout(set = 1, binding = 3) uniform sampler2D GBufferMatSpecular;
layout(set = 1, binding = 4) uniform sampler2D GBufferMatTransmittance;
layout(set = 1, binding = 5) uniform sampler2D GBufferNormal;
layout(set = 1, binding = 6) uniform sampler2D GBufferDepth;
layout(set = 1, binding = 8, rgba32f) uniform image2D directIlluminationOut;

void main()
{
	// Calculate launch data
	const uint launchIndex = calculateLaunchIndex(gl_LaunchIDEXT, gl_LaunchSizeEXT);
	const vec2 pixelCenter = gl_LaunchIDEXT.xy + vec2(0.5);
	const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
	uint seed = initSeed(launchIndex);

	// Calculate some params
	const mat4 invProj = inverse(camera.project);
	const mat4 invView = inverse(camera.view);
	const vec2 ndc = inUV * 2.0 - 1.0;

	// Get initial hit data from GBuffer
	float initialHitDepth = float(texture(GBufferDepth, inUV));
	vec3 wPos = depthToWorldPos(invProj, invView, ndc, initialHitDepth);
	vec3 wNormal = vec3(texture(GBufferNormal, inUV));
	vec3 Wi = vec3(invView * vec4(normalize((invProj * vec4(ndc, 1, 1)).xyz), 0));

	wNormal = normalize(wNormal);
	if (dot(wNormal, Wi) > 0.0) wNormal *= -1.0;

	// Get initial material data from GBuffer
	vec4 specularShininess = texture(GBufferMatSpecular, inUV);
	vec4 transmittanceIOR = texture(GBufferMatTransmittance, inUV);
	Material hitMaterial = Material(
		vec3(texture(GBufferAlbedo, inUV)),		// diffuse color
		specularShininess.rgb,					// specular color
		transmittanceIOR.rgb,					// transmittance
		vec3(texture(GBufferEmission, inUV)),	// emission color & strength
		specularShininess.a,					// shininess
		transmittanceIOR.a						// IOR
	);

	// Initialize ray payload
	diPayload.transmission = vec3(1);
	diPayload.energy = vec3(0);

	if (!gbufferRayHit(initialHitDepth))			// missed
	{
		diPayload.energy += diPayload.transmission * SKY_COLOR;
	}
	else if (luminance(hitMaterial.emission) > 0.0)	// Hit light
	{
		diPayload.energy += diPayload.transmission * hitMaterial.emission;
	}
	else
	{
		// TODO: some way of importance sampling lights in scene
		// evaluate material
		vec3 Wo = randomWalk(seed, Wi, wNormal);
		diPayload.transmission *= evaluatePDF(Wo, wNormal) * evaluateBRDF(Wi, Wo, wNormal, hitMaterial.diffuse);

		traceRayEXT(
			TLAS,
			gl_RayFlagsOpaqueEXT,
			0xFF,
			0, 0, 1,
			wPos,
			RAYTRACE_RANGE_TMIN,
			Wo,
			RAYTRACE_RANGE_TMAX,
			0
		);
	}

	imageStore(directIlluminationOut, ivec2(gl_LaunchIDEXT.xy), vec4(diPayload.energy, 1.0));
}
