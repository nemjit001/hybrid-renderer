#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "shader_common.glsl"
#include "raytracing_common.glsl"

layout(location = 0) rayPayloadEXT RayHitPayload prd;

layout(set = 0, binding = 0) uniform CAMERA { Camera camera; };

layout(set = 1, binding = 0) uniform accelerationStructureEXT TLAS;
layout(set = 1, binding = 1) uniform sampler2D GBufferAlbedo;
layout(set = 1, binding = 2) uniform sampler2D GBufferWorldPos;
layout(set = 1, binding = 3) uniform sampler2D GBufferNormal;
layout(set = 1, binding = 4, r32f) uniform image2D softShadowOut;
layout(set = 1, binding = 5, rgba32f) uniform image2D DirectIlluminationOut;

void main()
{
	const uint rayFlags = gl_RayFlagsOpaqueEXT;
	const uint cullMask = 0xFF;

	const uint launchIndex = gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x;
	const vec2 pixelLocation = gl_LaunchIDEXT.xy;
	const vec2 pixelCenter = pixelLocation + vec2(0.5);
	const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);

	// Initial ray hit stuff
	const mat4 invProj = inverse(camera.project);
	const mat4 invView = inverse(camera.view);
	const vec2 d = inUV * 2.0 - 1.0;

	// TODO: sample GBuffer Layout for material params & primary hit data to calculate new direction
	const vec3	diffuseColor = vec3(texture(GBufferAlbedo, inUV));

	const vec3 wPos = vec3(texture(GBufferWorldPos, inUV));
	const vec3 wNormal = vec3(normalize(texture(GBufferNormal, inUV)));
	const vec3 wInDir = vec3(invView * normalize(invProj * vec4(d.x, d.y, 1, 1)));
	const vec3 wOutDir = randomWalk(prd.seed, wNormal);

	// Initialize ray payload
	prd.seed = initSeed(launchIndex);
	prd.shadow = 0.0;
	prd.energy = vec3(0);
	prd.transmission = vec3(1);

	// Apply material params from GBuffer data
	prd.transmission = wPos;
	// prd.transmission *= evaluatePDF(wOutDir, wNormal) * evaluateBRDF(wInDir, wOutDir, wNormal, diffuseColor);

	// TODO: trace shadow rays for direct illumination

//	traceRayEXT(
//		TLAS,
//		rayFlags,
//		cullMask,
//		0,	// SBT record offset
//		0,	// SBT record stride
//		0,	// Miss shader index
//		wPos,
//		RAYTRACE_RANGE_TMIN,
//		wOutDir,
//		RAYTRACE_RANGE_TMAX,
//		0	// Payload location
//	);

	const ivec2 pixel = ivec2(pixelLocation);
	imageStore(softShadowOut, pixel, vec4(vec3(prd.shadow), 1));
	imageStore(DirectIlluminationOut, pixel, vec4(prd.transmission, 1));
}
