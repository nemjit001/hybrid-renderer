#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "shader_common.glsl"
#include "raytracing_common.glsl"

#define HYBRID_RENDERING	1

layout(location = 0) rayPayloadEXT RayHitPayload prd;

layout(set = 0, binding = 0) uniform CAMERA { Camera camera; };

layout(set = 1, binding = 0) uniform accelerationStructureEXT TLAS;
layout(set = 1, binding = 1) uniform sampler2D GBufferAlbedo;
layout(set = 1, binding = 2) uniform sampler2D GBufferEmission;
layout(set = 1, binding = 3) uniform sampler2D GBufferMatSpecular;
layout(set = 1, binding = 4) uniform sampler2D GBufferMatTransmittance;
layout(set = 1, binding = 5) uniform sampler2D GBufferNormal;
layout(set = 1, binding = 6) uniform sampler2D GBufferDepth;
layout(set = 1, binding = 7, r32f) uniform image2D softShadowOut;
layout(set = 1, binding = 8, rgba32f) uniform image2D DirectIlluminationOut;

void main()
{
	const uint rayFlags = gl_RayFlagsOpaqueEXT;
	const uint cullMask = 0xFF;

	// Calculate launch & pixel info
	const uint launchIndex = gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x;
	const vec2 pixelLocation = gl_LaunchIDEXT.xy;
	const vec2 pixelCenter = pixelLocation + vec2(0.5);
	const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);

	// Calculate initial ray data
	const mat4 invProj = inverse(camera.project);
	const mat4 invView = inverse(camera.view);
	const vec2 ndc = inUV * 2.0 - 1.0;

	// Initialize ray payload
	prd.seed = initSeed(launchIndex);
	prd.traceDepth = 0;
	prd.terminated = false;
	prd.origin = vec3(0);
	prd.direction = vec3(0);
	prd.energy = vec3(0.0);
	prd.transmission = vec3(1);

#if HYBRID_RENDERING == 1
	// Get initial hit data from GBuffer
	float initialHitDepth = float(texture(GBufferDepth, inUV));
	vec3 wPos = depthToWorldPos(invProj, invView, ndc, initialHitDepth);
	vec3 wNormal = vec3(texture(GBufferNormal, inUV));
	wNormal = normalize(wNormal);

	// Get material params from GBuffer
	vec4 specularShininess = texture(GBufferMatSpecular, inUV);
	vec4 transmittanceIOR = texture(GBufferMatTransmittance, inUV);

	Material hitMaterial = Material(
		vec3(texture(GBufferAlbedo, inUV)),		// diffuse color
		specularShininess.rgb,					// specular color
		transmittanceIOR.rgb,					// transmittance
		vec3(texture(GBufferEmission, inUV)),	// emission color & strength
		specularShininess.a,					// shininess
		transmittanceIOR.a						// IOR
	);
	

	// Evaluate initial material hit
	vec4 iRayDirection = invProj * vec4(ndc, 1, 1);
	vec3 wRayOrigin = vec3(invView * vec4(0, 0, 0, 1));
	vec3 wInDir = vec3(invView * vec4(normalize(iRayDirection.xyz), 0));
	
	if (initialHitDepth == 1.0)
	{
		prd.terminated = true;
		prd.energy += prd.transmission * sampleSkyColor(wInDir);
	}

	if (isEmissive(hitMaterial.emission))
	{
		prd.terminated = true;
		prd.energy += prd.transmission * hitMaterial.emission;
	}

	if (dot(wNormal, wInDir) > 0.0)
		wNormal *= -1.0;

	vec3 wOutDir = randomWalk(prd.seed, wInDir, wNormal);
	float pdf = evaluatePDF(wOutDir, wNormal);
	vec3 brdf = evaluateBRDF(wInDir, wOutDir, wNormal, hitMaterial.diffuse);
	prd.transmission *= pdf * brdf;
#else
	vec4 iRayDirection = invProj * vec4(ndc, 1, 1);
	vec3 wPos = vec3(invView * vec4(0, 0, 0, 1));
	vec3 wOutDir = vec3(invView * vec4(normalize(iRayDirection.xyz), 0));
#endif

	prd.origin = wPos;
	prd.direction = wOutDir;

	if (!prd.terminated)
	{
		prd.traceDepth++;
		traceRayEXT(
			TLAS,
			rayFlags,
			cullMask,
			0,	// SBT record offset
			0,	// SBT record stride
			0,	// Miss shader index
			prd.origin,
			RAYTRACE_RANGE_TMIN,
			prd.direction,
			RAYTRACE_RANGE_TMAX,
			0	// Payload location
		);
	}

	const ivec2 pixel = ivec2(pixelLocation);
	imageStore(DirectIlluminationOut, pixel, vec4(prd.energy, 1));
}
