#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "shader_common.glsl"
#include "raytracing_common.glsl"

layout(location = 0) rayPayloadEXT RayHitPayload prd;

layout(set = 0, binding = 0) uniform CAMERA { Camera camera; };

layout(set = 1, binding = 0) uniform accelerationStructureEXT TLAS;
layout(set = 1, binding = 1) uniform sampler2D GBufferWorldPos;
layout(set = 1, binding = 2) uniform sampler2D GBufferNormal;
layout(set = 1, binding = 3, r32f) uniform image2D softShadowOut;

void main()
{
	const uint rayFlags = gl_RayFlagsOpaqueEXT;
	const uint cullMask = 0xFF;
	const uint sbtRecordOffset = 0;
	const uint sbtRecordStride = 0;
	const uint missIndex = 0;

	const vec2 pixelLocation = gl_LaunchIDEXT.xy;
	const vec2 pixelCenter = pixelLocation + vec2(0.5);
	const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);

	// TODO: sample GBuffer Layout for material params & primary hit data to calculate new direction
	const vec3 wOrigin = vec3(normalize(texture(GBufferWorldPos, inUV)));
	const vec3 wNormal = vec3(normalize(texture(GBufferNormal, inUV)));
	const vec3 wOutDirection = randomWalk(wNormal);

	// TODO: trace shadow rays

	traceRayEXT(
		TLAS,
		rayFlags,
		cullMask,
		sbtRecordOffset,
		sbtRecordStride,
		missIndex,
		wOrigin,
		RAYTRACE_RANGE_TMIN,
		wOutDirection,
		RAYTRACE_RANGE_TMAX,
		0
	);

	imageStore(softShadowOut, ivec2(pixelLocation), vec4(vec3(prd.shadow), 1));
}
