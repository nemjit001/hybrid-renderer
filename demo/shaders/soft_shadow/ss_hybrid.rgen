#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#include "../shader_common.glsl"
#include "../raytracing_common.glsl"

layout(location = 0) rayPayloadEXT SSRayPayload ssPayload;

layout(set = 0, binding = 0) uniform CAMERA { Camera camera; };

layout(set = 1, binding = 0) uniform accelerationStructureEXT TLAS;
layout(set = 1, binding = 2) uniform sampler2D GBufferEmission;
layout(set = 1, binding = 5) uniform sampler2D GBufferNormal;
layout(set = 1, binding = 6) uniform sampler2D GBufferDepth;
layout(set = 1, binding = 7, r32f) uniform image2D softShadowOut;

void main()
{
	// Calculate launch data
	const uint launchIndex = calculateLaunchIndex(gl_LaunchIDEXT, gl_LaunchSizeEXT);
	const vec2 pixelCenter = gl_LaunchIDEXT.xy + vec2(0.5);
	const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
	uint seed = initSeed(launchIndex);

	// Calculate some params
	const mat4 invProj = inverse(camera.project);
	const mat4 invView = inverse(camera.view);

	// Get hit data
	HybridInitialHit hit = getInitialHitData(invView, invProj, inUV, GBufferNormal, GBufferDepth);

	// Initialize ray payload
	ssPayload.miss = false;

	if (luminance(texture(GBufferEmission, inUV).rgb) > 0.0 || hit.miss)
		ssPayload.miss = true;

	if (!hit.miss)
	{
		// TODO: some way of importance sampling lights in scene
		vec3 Wo = randomWalk(seed, hit.Wi, hit.worldNormal);

		traceRayEXT(
			TLAS,
			gl_RayFlagsOpaqueEXT
			| gl_RayFlagsSkipClosestHitShaderEXT
			| gl_RayFlagsTerminateOnFirstHitEXT,
			0xFF,
			0, 0, 0,
			hit.worldPos,
			RAYTRACE_RANGE_TMIN,
			Wo,
			RAYTRACE_RANGE_TMAX,
			0
		);
	}

	imageStore(softShadowOut, ivec2(gl_LaunchIDEXT.xy), vec4(ssPayload.miss));
}
