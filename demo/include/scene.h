#pragma once

#include <hybrid_renderer.h>
#include <string>

#include "detail/raytracing.h"
#include "material.h"

#define INVALID_SCENE_ID	(size_t)(~0)
#define DEFAULT_LOD_FAR		100.0f
#define MAX_LOD_LEVELS		3

/// @brief Scene parameters allow modifying LOD selection.
struct SceneParameters
{
	float nearPoint = 0.0f;
	float farPoint	= DEFAULT_LOD_FAR;
};

/// @brief A Scene Transform is a simple collection of vectors representing translation, rotation, and scale.
struct SceneTransform
{
	hri::Float3 position	= hri::Float3(0.0f, 0.0f, 0.0f);
	hri::Float3 rotation	= hri::Float3(0.0f, 0.0f, 0.0f);
	hri::Float3 scale		= hri::Float3(1.0f, 1.0f, 1.0f);

	/// @brief Create a 4x4 transformation matrix representing the model transfom.
	/// @return An hri::Float4x4 matrix.
	inline hri::Float4x4 modelMatrix() const;
};

/// @brief A Scene Node represents an entry into the SceneGraph, with data relevant for rendering.
struct SceneNode
{
	typedef size_t SceneId;

	std::string name					= "No Name";
	SceneTransform transform			= SceneTransform{};
	SceneId material					= INVALID_SCENE_ID;
	SceneId meshLODs[MAX_LOD_LEVELS]	= { INVALID_SCENE_ID, INVALID_SCENE_ID, INVALID_SCENE_ID };
};

/// @brief A render instance a model matrix and a pointer to instance data.
struct RenderInstance
{
	hri::Float4x4 modelMatrix;
	uint32_t instanceId;
};

/// @brief Render Instance Data contains offsets into scene buffers & buffer addresses for objects.
struct RenderInstanceData
{
	uint32_t materialIdx;
	uint32_t indexCount;
	VkDeviceAddress vertexBufferAddress;
	VkDeviceAddress indexBufferAddress;
};

/// @brief Scene buffers store device local resources for a scene
struct SceneBuffers
{
	hri::BufferResource instanceDataSSBO;
	hri::BufferResource materialSSBO;
};

class SceneASManager
{
public:
	SceneASManager(
		raytracing::RayTracingContext& ctx,
		const std::vector<hri::Mesh>& meshes
	);

	virtual ~SceneASManager() = default;

	bool shouldReallocTLAS(
		const raytracing::AccelerationStructure& tlas,
		const std::vector<RenderInstance>& instances,
		const std::vector<raytracing::AccelerationStructure>& blasList
	) const;

	raytracing::AccelerationStructure createTLAS(
		const std::vector<RenderInstance>& instances,
		const std::vector<raytracing::AccelerationStructure>& blasList
	);

	std::vector<raytracing::AccelerationStructure> createBLASList(const std::vector<hri::Mesh>& meshes);

	void cmdBuildTLAS(
		VkCommandBuffer commandBuffer,
		const std::vector<RenderInstance>& instances,
		const std::vector<raytracing::AccelerationStructure>& blasList,
		raytracing::AccelerationStructure& tlas
	) const;

	void cmdBuildBLASses(
		VkCommandBuffer commandBuffer,
		const std::vector<RenderInstance>& instances,
		const std::vector<hri::Mesh>& meshes,
		const std::vector<raytracing::AccelerationStructure>& blasList
	) const;

private:
	hri::BufferResource generateTLASInstances(
		const std::vector<RenderInstance>& instances,
		const std::vector<raytracing::AccelerationStructure>& blasList
	) const;

	std::vector<raytracing::ASBuilder::ASInput> generateBLASInputs(const std::vector<hri::Mesh>& meshes) const;

private:
	raytracing::RayTracingContext& m_ctx;
	raytracing::ASBuilder m_asBuilder;
};

class SceneGraph
{
public:
	/// @brief Create a new scene graph.
	/// @param ctx Ray Tracing Context to use.
	/// @param materials Materials in the scene.
	/// @param meshes Meshes in the scene.
	/// @param nodes SceneNodes list representing mesh & material instance locations.
	SceneGraph(
		raytracing::RayTracingContext& ctx,
		std::vector<Material>&& materials,
		std::vector<hri::Mesh>&& meshes,
		std::vector<SceneNode>&& nodes
	);

	/// @brief Destroy this scene graph.
	virtual ~SceneGraph() = default;

	/// @brief Update the SceneGraph.
	/// @param deltaTime Time delta for this frame.
	void update(float deltaTime);

	/// @brief Retrieve cached instance list generated by the latest call to SceneGraph::generateRenderInstanceList.
	/// @return Cached instance data.
	const std::vector<RenderInstance>& getRenderInstanceList() const;

	/// @brief Generate instance list based on camera position, calculating LOD levels & returning an instance list.
	/// @param camera Camera to use for LOD generation.
	/// @return A newly generated list of render instances.
	const std::vector<RenderInstance>& generateRenderInstanceList(const hri::Camera& camera);

	inline const RenderInstanceData& getInstanceData(size_t idx) const { return m_instanceData.at(idx); }

private:
	/// @brief Calculate the LOD level for a given scene node.
	/// @param camera Camera to use for LOD generation.
	/// @param node Node to calculate LOD for.
	/// @return A SceneId pointing to a mesh LOD in the mesh list.
	SceneNode::SceneId calculateLODLevel(const hri::Camera& camera, const SceneNode& node);

public:
	SceneParameters parameters;
	std::vector<Material> materials;
	std::vector<hri::Mesh> meshes;
	std::vector<SceneNode> nodes;
	uint32_t lightCount;
	SceneASManager accelStructManager;
	SceneBuffers buffers;

private:
	raytracing::RayTracingContext& m_ctx;
	raytracing::ASBuilder m_asBuilder;
	std::vector<RenderInstanceData> m_instanceData	= {};
	std::vector<RenderInstance> m_instances			= {};
};

/// @brief The SceneLoader handles loading scene files from disk.
class SceneLoader
{
public:
	/// @brief Load a new Scene File.
	/// @param context Ray Tracing Context to use.
	/// @param path Path to the scene file.
	/// @return A new SceneGraph generated from the scene file.
	static SceneGraph load(raytracing::RayTracingContext& context, const std::string& path);

private:
	/// @brief Load an OBJ Mesh from an OBJ file.
	/// @param path File path.
	/// @param name Name of the mesh to load.
	/// @param material Material reference optionally populated by the loader.
	/// @param vertices Vertex list reference populated by the loader.
	/// @param indices Index list reference populated by the loader.
	/// @param loadMaterial Boolean indicating whether the mesh's material should be loaded.
	/// @return A boolean indicating success or failure.
	static bool loadOBJMesh(
		const std::string& path,
		const std::string& name,
		Material& material,
		std::vector<hri::Vertex>& vertices,
		std::vector<uint32_t>& indices,
		bool loadMaterial
	);
};

inline hri::Float4x4 SceneTransform::modelMatrix() const
{
	hri::Float4x4 out = hri::Float4x4(1.0f);
	out = glm::translate(out, static_cast<vec3>(position));
	out = glm::rotate(
		glm::rotate(
			glm::rotate(
				out, hri::radians(rotation.y), static_cast<vec3>(HRI_WORLD_UP)
			), hri::radians(rotation.z), static_cast<vec3>(HRI_WORLD_FORWARD)
		), hri::radians(rotation.x), static_cast<vec3>(HRI_WORLD_RIGHT)
	);
	out = glm::scale(out, static_cast<vec3>(scale));

	return out;
}
